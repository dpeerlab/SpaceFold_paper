library(dplyr)

#utility functions to add annotation / subset BayesPrism output


#' add annotation dataframe (meta) to a BayesPrism output
#' @param bp.obj a BayesPrism output object
#' @param meta a dataframe that annotates the visium spots, usually with the following columns:
	#barcode sample tissue row col imagerow  imagecol Cluster height width sum_umi sum_gene
	#add.meta will create an entry meta in bp.obj$para by matching barcode to rownames(bp.obj$para$X)
add.meta <- function(bp.obj, meta=NULL, selected.sample=NULL){
	
	bp.barcode <- rownames(bp.obj$para$X)
	
	if(!is.null(selected.sample)){
		#subset by the sample column
		meta <- meta[meta $sample== selected.sample,]
	}
	
	stopifnot(sum(bp.barcode %in% meta$barcode)==length(bp.barcode))
	
	if(!is.null(meta)) meta.matched <- meta[match(bp.barcode, meta $barcode),]
	else meta.matched <- data.frame(barcode= bp.barcode, sample = selected.sample)
	
	bp.obj$para$meta <- meta.matched
	bp.obj
}
# #test
# load("/lila/data/peer/tinyi/RU_data/visium/dat/visium_dat/LI/visium.LI.WhiteSketch.rdata")
# load("/lila/data/peer/tinyi/RU_data/visium/dat/bp_dat/from_reprocessed_anndata/LI/merge_finer_states_0930/WTLI1.bp.rdata")
# WTLI1.bp <- add.meta (bp.obj=WTLI1.bp, meta= bcs_merge, selected.sample="WTLI1")


#' add labels, e.g. created by selecting spots in the Loupe browser, to the meta entry of the BayesPrism output
#' @param bp.obj a BayesPrism output object
#' @label.df a dataframe (generated by selecting spots from loupe browser). First column is barcode, second column is the label. 
add.region.labels <- function(bp.obj, label.df){
	stopifnot(!is.null(bp.obj$para$meta))
	
	colnames(label.df)[colnames(label.df)=="Barcode"] <- "barcode"
	
	meta.new <- merge(bp.obj$para$meta, 
									  label.df, 
									  by = "barcode",
									  all.x=TRUE)
	
	meta.new[,ncol(meta.new)][is.na(meta.new[,ncol(meta.new)])] <- "unassigned"
	
	bp.obj$para$meta <- meta.new
	
	bp.obj
}

#test
# label.df <- read.csv("/data/peer/tinyi/RU_data/visium/dat/visium_dat/region_labeled/WTLI1_region.csv")
# WTLI1.bp <- add.region.labels(WTLI1.bp, label.df)


#' add gene annotation dataframe (feature) to a BayesPrism output
#' @param bp.obj a BayesPrism output object
#' @param feature a dataframe that annotates the genes (colnames of X), with rownames to be matched the colnames(bp.obj$para$X),
	#usually with the following columns: ESEMBLE ID, gene symbol, etc...
	#add.feature will create an entry feature in bp.obj$para by matching rownames of feature to colnames(bp.obj$para$X)
add.feature <- function(bp.obj, feature){
	
	bp.genes <- colnames(bp.obj$para$X)
	
	stopifnot(sum(bp.genes %in% rownames(feature))==length(bp.genes))
	
	feature.matched <- feature[match(bp.genes, rownames(feature)),]
	
	bp.obj$para$feature <- feature.matched
	bp.obj
}

#test
# gene.tab <- read.table("/fscratch/tinyi/RU_data/Org/dat/scRNAseq_organoids_1st_trial/SIorganoids_outs/outs/raw_feature_bc_matrix/features.tsv.gz",sep="\t",check.names=F,header=F)[,1:2]
# colnames(gene.tab) <- c("id",'symbol')
# rownames(gene.tab) <- gene.tab[,"id"]
# WTLI.bp.merged <- add.feature (WTLI.bp.merged, gene.tab)


#' subset BayesPrism object by row (mixture sample id)
#' @param bp.obj a BayesPrism output object
#' @param sub.idx a logical vector of the same length as mixture samples
subset.row <- function(bp.obj, sub.idx){
	stopifnot(nrow(bp.obj$para$X)==length(sub.idx))
	
	bp.obj$para$X <- bp.obj$para$X[sub.idx,]
	if(!is.null(bp.obj$para$meta)) bp.obj$para$meta <- bp.obj$para$meta[sub.idx,]

	bp.obj$res$first.gibbs.res$gibbs.theta <- bp.obj$res$first.gibbs.res$gibbs.theta[sub.idx,]
	bp.obj$res$first.gibbs.res$theta.merged <- bp.obj$res$first.gibbs.res$theta.merged[sub.idx,]	
	bp.obj$res$first.gibbs.res$Znkg <- bp.obj$res$first.gibbs.res$Znkg[sub.idx,,]
	bp.obj$res$first.gibbs.res$Znkg.merged <- bp.obj$res$first.gibbs.res$Znkg.merged[sub.idx,,]
	bp.obj$res$final.gibbs.theta <- bp.obj$res$final.gibbs.theta[sub.idx,]
	
	if(!is.null(bp.obj$res$first.gibbs.res$Znk)) {
		bp.obj$res$first.gibbs.res$Znk <- bp.obj$res$first.gibbs.res$Znk[sub.idx,]
		bp.obj$res$first.gibbs.res$Znk.merged <- bp.obj$res$first.gibbs.res$Znk.merged[sub.idx,]
	}
	
	if(!is.null(bp.obj$res$first.gibbs.res$Znkg.merged.normed)){
		bp.obj$res$first.gibbs.res$Znkg.merged.normed <- bp.obj$res$first.gibbs.res$Znkg.merged.normed[sub.idx,,]
	}
	
	if(!is.null(bp.obj$res$res.regroup)){
		bp.obj$res$res.regroup$theta0 <- bp.obj$res$res.regroup$theta0[sub.idx,]
		bp.obj$res$res.regroup$Znkg <- bp.obj$res$res.regroup$Znkg[sub.idx,,]
		bp.obj$res$res.regroup$Znk <- bp.obj$res$res.regroup$Znk[sub.idx,]
		bp.obj$res$res.regroup$thetaF <- bp.obj$res$res.regroup$thetaF[sub.idx,]
		bp.obj$res$res.regroup$Znkg.normed <- bp.obj$res$res.regroup$Znkg.normed[sub.idx,,]
	}
	
	#background level is not subsetted
	
	bp.obj
}




#' subset BayesPrism object based on region
#' @param bp.obj a BayesPrism output object
#' @param col.name the column name of the meta dataframe
#' @param val the value on the right hand side comparison operator
#' @param operator the character denoting the comaprison, e.g. "==", ">", "<". default is "==".
subset.bp <- function(bp.obj, 
					  col.name, 
					  val,
					  operator="=="){
	
	if(is.character(val)) val <- paste("\'", val, "\'",sep="")
	
	exp.text <- paste( "bp.obj$para$meta$", col.name, " ", operator, " ",  val,sep="")
	sub.idx <- eval ( parse(text = exp.text)  )
	
	subset.row(bp.obj, sub.idx)
	
}

#test
#WTLI1.top.bp <- subset.bp(WTLI1.bp, "region","top")


#' update cell type names in the BayesPrism object
#' @param bp.obj a BayesPrism output object
#' @param old.name.vec a character vector containing the old names of cell types to be substituted
#' @param new.name.vec a character vector containing the new names of cell types used to replace the old names
update.name <- function(bp.obj, old.name.vec, new.name.vec){
	stopifnot(length(old.name.vec)==length(new.name.vec))
	
	current.cell.types.all  <- colnames(bp.obj$res$first.gibbs.res$theta.merged)
	new.name.vec <- new.name.vec[old.name.vec %in% current.cell.types.all]	
	old.name.vec <- old.name.vec[old.name.vec %in% current.cell.types.all]
	
	if(length(old.name.vec)==0) return(bp.obj) # nothing to replace
	update_name_each <- function(input){
		# cell types are at the second dimension for both theta and Znkg 
		dimnames(input)[[2]][match(old.name.vec , dimnames(input)[[2]])] <- new.name.vec
		return(input)
	}
	
	bp.obj$res$first.gibbs.res$theta.merged <- update_name_each(bp.obj$res$first.gibbs.res$theta.merged)
	bp.obj$res$first.gibbs.res$Znkg.merged <- update_name_each(bp.obj$res$first.gibbs.res$Znkg.merged)
	bp.obj$res$final.gibbs.theta <- update_name_each(bp.obj$res$final.gibbs.theta)
	
	bp.obj
}

#test
#WTLI.bp.merged <- update.name(WTLI.bp.merged, old.name.vec= "goblet_2+8", new.name.vec="goblet_2_8")


#' function to compute Znk merged (reads per cell type per spot)
#' @param bp.obj a BayesPrism output object
compute.Znk <- function(bp.obj){
	bp.obj$res$first.gibbs.res$Znk <- rowSums(bp.obj$res$first.gibbs.res$Znkg,dims=2)
	bp.obj$res$first.gibbs.res$Znk.merged <- rowSums(bp.obj$res$first.gibbs.res$Znkg.merged,dims=2)
	bp.obj
}
#test
#WTLI.bp.merged <- compute.Znk(WTLI.bp.merged)


#' sum over multiple cell states / cell types for theta, Znkg and Znk(if exist)
#' @param bp.obj a BayesPrism output object
#' @param grouping.list a named list containing the cell states / cell types to be summed, with name denoting the corresponding cell type 
#' @param return.merge.only a logical variable denoting if only returns the regrouped results or the full bp.obj with a new entry "XXX.regrouped" added to the $res entry
regroup.bp <- function(bp.obj,
					   state.or.type=c("state","type"),
					   grouping.list,
					   return.merge.only=FALSE){
	
	#summing over theta (or Znk)
	sum.theta <- function(theta, grouping.list){
		theta.sum <- matrix(NA,
							nrow=nrow(theta),
							ncol=length(grouping.list),
							dimnames=list(rownames(theta),names(grouping.list)))
		
		for(i in 1:length(grouping.list)){
			cell.types.i <- grouping.list[[i]]
			if(length(cell.types.i)==1) theta.sum[,i] <- theta[, cell.types.i]
			else theta.sum[,i] <- apply(theta[, cell.types.i], 1,sum)
		}
		theta.sum
	}
	
	#summing over Znkg
	sum.Znkg <- function(Znkg, grouping.list){
		
		Znkg.sum <- array(NA,
						  dim=c(dim(Znkg)[1],length(grouping.list),dim(Znkg)[3]),
						  dimnames = list(dimnames(Znkg)[[1]], 
	 			                         names(grouping.list),
	 			                         dimnames(Znkg)[[3]]))
	 			                   
		for(i in 1:length(grouping.list)){
			cell.types.i <- grouping.list[[i]]
			Znkg.i <- Znkg[,cell.types.i,]
			if(length(dim(Znkg.i))==2) Znkg.sum[,i,] <- Znkg.i
			else Znkg.sum[,i,] <- apply(Znkg.i,c(1,3),sum)
		}
		Znkg.sum
	}
	
	stopifnot(!is.null(names(grouping.list)))
	
	if(state.or.type == "state") {
		theta <- bp.obj$res$first.gibbs.res$gibbs.theta
		Znkg <- bp.obj$res$first.gibbs.res$Znkg
		Znk <- bp.obj$res$first.gibbs.res$Znk
		if(is.null(Znk)) {
			bp.obj <- compute.Znk (bp.obj)
			Znk <- bp.obj$res$first.gibbs.res$Znk
		}
	}	
	
	if(state.or.type == "type") {
		theta <- bp.obj$res$first.gibbs.res$theta.merged
		Znkg <- bp.obj$res$first.gibbs.res$Znkg.merged
		Znk <- bp.obj$res$first.gibbs.res$Znk.merged
		if(is.null(Znk)) {
			bp.obj <- compute.Znk (bp.obj)
			Znk <- bp.obj$res$first.gibbs.res$Znk.merged
		}
	}
	
	all.cell.types <- colnames(theta)
	stopifnot(sum(unlist(grouping.list) %in% all.cell.types)==length(unlist(grouping.list)))
	
	res.regrouped <- list()
	res.regrouped$theta0 <- sum.theta (theta, grouping.list)
	res.regrouped$Znkg <- sum.Znkg (Znkg, grouping.list)
	res.regrouped$Znk <- sum.theta (Znk, grouping.list)
	if(state.or.type == "type"){
		#merged the final gibbst if merging cell types
		thetaF <- bp.obj$res$final.gibbs.theta
		if(!is.null(thetaF)) res.regrouped$thetaF <- sum.theta (thetaF, grouping.list)
	}
	
	#renormalized the regrouped entry
	Znkg.normed <- res.regrouped$Znkg
	for(k in 1:dim(Znkg.normed)[2]) Znkg.normed[,k,] <- res.regrouped$Znkg[,k,] / res.regrouped$Znk[,k]
	res.regrouped$Znkg.normed <- Znkg.normed
	
	#determine the new cutoffs using the min of the original cutoffs in each group
	background.level <- bp.obj$res$background.level
	if(!is.null(background.level)){
		selected.spot.matrix.regrouped <- do.call(cbind, 
												  lapply(grouping.list, 
												  		function(i) apply(background.level$selected.spot.matrix[,i,drop=F],1,sum)>0))
		colnames(selected.spot.matrix.regrouped) <- names(grouping.list)
		
		res.regrouped$background.level$which.theta <- background.level$which.theta
		res.regrouped$background.level$selected.spot.matrix <- selected.spot.matrix.regrouped
	}
	
	if(return.merge.only) return(res.regrouped)
	else {
		bp.obj$res$res.regrouped <- res.regrouped
		return(bp.obj)
	}
	bp.obj
}

#test
# grouping.list <- list(diff.epi.cells = c("goblet_3","goblet_2_8","goblet_1","goblet_5","goblet_4","enterendocrine","tuft","mature_enterocyte_2","mature_enterocyte_1"),
	# lgr5_cells=c("Lgr5+_stem_cycling","Lgr5+_stem"),
	# str.cells = c("str3","str1.1","str2","myofibroblast"),
	# endothelial="endothelial",
	# lymphatic="lymphatic",
	# Bcell="Bcell",
	# macrophage="macrophage",
	# activated_macrophage="activated_macrophage",
	# plasma="plasma",
	# cycling_plasma="cycling-plasma",
	# glial="glial"
# )

# res.regrouped <- regroup.bp(WTLI.bp.merged, "type", grouping.list,TRUE)
# WTLI.bp.merged <- regroup.bp(WTLI.bp.merged, "type", grouping.list,FALSE)


#' function to compute normalized expression per cell type per spot, Znkg, by the size factor of each cell type in each spot, Znk
#' @param bp.obj a BayesPrism output object
norm.by.sf <- function(bp.obj){
	
	Znkg.merged <- bp.obj$res$first.gibbs.res$Znkg.merged
	Znk.merged <- bp.obj$res$first.gibbs.res$Znk.merged
	
	if(is.null(Znk.merged)) {
		bp.obj <- compute.Znk(bp.obj)
		Znk.merged <- bp.obj$res$first.gibbs.res$Znk.merged
	}
	
	if(is.null(bp.obj$res$first.gibbs.res$Znkg.merged.normed)){
		Znkg.merged.normed <- Znkg.merged
		for(k in 1:dim(Znkg.merged.normed)[2]) Znkg.merged.normed[,k,] <- Znkg.merged[,k,] / Znk.merged[,k]
		bp.obj$res$first.gibbs.res$Znkg.merged.normed <- Znkg.merged.normed
	}
		
	bp.obj
}

#test
#WTLI.bp.merged <- norm.by.sf(WTLI.bp.merged)


#group











